# なぜ v3 で新規作成したか

- v2 までは BE を使用していて、正直スペックと実際の機能としてやりすぎ感が拭えない。なので v3 で方針を変更して、DB とユーザー認証は全て firebase を使用して対応することとした。(仕事だったら凝って全然いいけど、プライベートで個人開発としてはやりすぎ)

## 今後の TODO

1. DDD の思想に沿った構成にしてみる(大まかな機能ができて余裕が持てた後の話)

- 階層としては useStore(各ユースケースごとに非同期データフェッチやキャッシュ管理) > store(グローバル値保持) > ドメインサービス(ユースケース)(集約の概念的に、ルートエンティティの元、複数のエンティティを用いてビジネスロジックを実際に書くところ)(集約のビジネスロジック) & ドメインエンティティ(単体エンティティのビジネスロジック&値自体をセキュアに更新・保持)

2. 原子性をどうするか

- 現状、ほとんどユースケース単位でデータの書き換え API を読んでいるため、複数のレポジトリを使用している。そのため、一つのレポジトリでは更新処理が成功して、もう片方は失敗することで整合性が取れなくなる可能性が現状ある。
- 一案：firebase にもトランザクションをひとまとめにする（dynamoDB の Batch 的な）ものがあったため、usecase ごとにそれでくくることが考えられる。懸念点としては、役割的に infra 層に当たる関数そう？？

2. 自分と一度無料で相談できる NFT トークンを発行する

- 「Not a hotel」 という NFT と DAO を利用したアプリでは、NFT 発行時点で 2024/9/12 にホテル宿泊可能といった感じでトークンを発行していた。それか、2024~2070 まで一年に一回無料でホテルに宿泊可能といった使い方もしていた。
  - 上記のフローとしては、目的：自分たちのガバナンストークンの価値を上げたい ⇨ お客さんにトークンを買ってもらう必要がある ⇨ 買ってくれたらインセンティブとして一年に一回無料でホテルに宿泊できる（一泊 50 万円相当）⇨ 結論：銀行を介さずにお金を借りることができている。
  - これ真似して JAEL のガバナンストークンの価値も上げていこ

## アーキテクト

- zustand で各エンティティの store を管理する。そして store 内で infra 層の repository を使用することで、セキュア(他の UI 層で直接値をいじられないような)なデータ管理を行うことができる(TODO: エンティティの値を変えたい場合は domain 層のビジネスロジックとしてメソッドを追加してアプリケーション層のユースケースで修正できるようにする)

## Chat GPT

- https://chatgpt.com/share/67e85872-5fc8-8011-93c0-c08a5c716fbf
